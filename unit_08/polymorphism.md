# Полиморфизм

**Полиморфизм** – это способность программы идентично использовать объекты с
одинаковым интерфейсом без информации о конкретном типе этого объекта.

Подход ООП подразумевает построение Java-программы на основе взаимодействии объектов, которые базируются на классах.
Классы – это заранее написанные чертежи (шаблоны), по которым будут созданы объекты в программе.
Причем класс всегда имеет определенный тип, который при хорошем стиле программирования своим названием «подсказывает» о своем предназначении.

Поскольку Java относится к строго типизированным языкам, в программном коде всегда нужно указать тип объекта при объявлении переменных.
Строгая типизация повышает безопасность кода, и надежность программы и позволяет еще на стадии компиляции 
предотвратить ошибки несовместимости типов (например, попытку разделить строку на число).
Естественно, компилятор должен «знать» объявляемый тип – это может быть класс из JDK или созданный собственноручно. 

При работе с программным кодом мы можем использовать не только объекты типа,
который мы назначили при объявлении, но и его наследников.
Это важный момент: мы можем работать со многими типами, как с одним
(при условии, что эти типы являются производными от базового типа).
Ообъявив переменную типа суперкласса, мы можем присвоить ей значение одного из наследников. 

При объявлении переменной типа суперкласса и присваивании ей значение одного из наследников происходит восходящее преобразование типов — 
ссылка на объект интерпретируется, как ссылка на базовый класс. 
Причем компилятор, встретив в коде такую конструкцию, делает это автоматически и неявно.

```java
class Animal {
    public void say() {
        System.out.println("mrgl-mrgl");
    }
}

class Dog extends Animal{
    
    public void say() {
        System.out.println("wow-wow");
    }
    
    public static void main(String[] args){
      Animal animal = new Dog();
    }
}
```

И если рассуждать о потомках, следует заметить, что наследование в Java — это не только extends, но и implements.
В Java не поддерживается множественное наследование — каждый тип может иметь одного родителя (суперкласс) 
и неограниченное количество наследников (подклассов).
Поэтому для добавления нескольких функциональностей в классы используются интерфейсы. 

##### В Java полиморфизм можно реализовать через:

-   **наследование** - с переопределением параметров и методов базового класса
-   **абстрактные классы** - шаблоны для раздельной реализации в разных классах
-   **интерфейсы** - для имплементации классами

---

### Интерфейсы (Interfaces)

**Интерфейс** — это совокупность методов и правил взаимодействия элементов системы.
Интерфейс определяет как элементы будут взаимодействовать между собой.

Интерфейсы уменьшают связанность объектов с родителем по сравнению с наследованием и используются очень широко.
В Java интерфейс является ссылочным типом, поэтому в программе может быть объявлен тип переменой типа интерфейса.

```java
public interface Runner {
    void run();
}
```

Возьмем разные и не связанные между собой объекты и реализуем в них интерфейс:

```java
class Puma implements Runner {
    public void run() {
        //implementation 
    }
}

class Tiger implements Runner {
    public void run() {
        //implementation
    }
}

public class Test {

    public static void main(String[] args) {
        Runner puma = new Puma();
        Runner tiger = new Tiger();

        List<Runner> runners = Arrays.asList(puma, tiger);
        for (Runner r : runners) {
            s.run();
        }
    }
}
```

Происходит позднее (динамическое) связывание (связь между вызовом метода и его конкретной реализацией в классах) 
По сути, определяется код, какого из 2 методов, определенных в классах, будет выполнен.

В Java по умолчанию используется позднее связывание (на стадии выполнения программы, а не во время компиляции, как в случае с ранним связыванием).
Это значит, что при компиляции кода компилятор еще не знает, код из какого класса — Puma, Tiger он будет исполнять в методе run.
Это определится только при выполнении программы благодаря механизму динамической диспетчеризации — 
проверки типа объекта во время выполнения программы и выбора нужной реализации метода для этого типа. 

При загрузке и инициализации объектов JVM строит таблицы в памяти, и в них связывает переменные с их значениями,а объекты — с их методами.
Причем если объект наследуется или имплементирует интерфейс, в первую очередь проверяется наличие переопределенных методов в его классе.
Если таковые есть, они привязываются к этому типу, если нет – ищется метод,
определенный в классе на ступень выше (в родителе) и так вплоть до корня при многоуровневой иерархии.

Хорошей практикой является использование абстрактных описаний для определения базовых классов с помощью абстрактных классов,а также интерфейсов. 
Эта практика основана на использовании абстракции — выделении общего поведения и свойств и заключении их в рамки абстрактного класса,
или выделении только общего поведения – в таком случае мы создаем интерфейс. 

Построение и проектирование иерархии объектов на основе интерфейсов и наследовании классов 
является обязательным условием для выполнения принципа полиморфизма ООП. 

Начиная с Java 8, есть возможность написания реализации по умолчанию (дефолтной) абстрактных методов в базовых классах с помощью ключевого слова `default`. 

Чтобы не нарушался принцип полиморфизма, методы не должны быть **static**, **private** и **final**:

-   **Private** делает метод доступным только в классе, и вы не сможете его переопределить в наследнике.
-   **Static** делает метод достоянием класса, а не объекта, поэтому всегда будет вызываться метод суперкласса.
-   **Final** же сделает метод неизменяемым и скрытым от наследников. 

---

### Достоинства полиморфизма

-   Позволяет объединять объекты с общим типом или поведением в одну коллекцию или массив и управлять ими единообразно.
-   Гибкость при создании новых типов: вы можете выбирать реализацию метода из родителя или переопределить его в потомке.
-   Позволяет подменять реализации объектов.
    На этом основано тестирование.
-   Обеспечивает расширяемость программы — становится гораздо легче создавать задел на будущее.
    Добавление новых типов на основе существующих — наиболее частый способ расширения функциональности программ, написанных в ООП стиле.

---

### [Назад к оглавлению](./README.md)

