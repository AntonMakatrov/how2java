# Сортировка массива

- [Сортировка выбором](#Сортировка-выбором-(Selection-sort))
- [Сортировка пузырьком](#Сортировка-пузырьком-(Bubble-sort))
- [Быстрая сортировка](#Быстрая-сортировка-(Quick-sort))
- [Случайная быстрая сортировка](#Случайная-быстрая-сортировка-(Random-quick-sort))
- [Сортировка слиянием](#Сортировка-слиянием-(Merge-sort))
- [Сортировка подсчетом](#Сортировка-подсчетом-(Counting-sort))
- [Способы оценки алгоритма](#Способы-оценки-алгоритма)
- [Свойства алгоритмов сортировки](#Свойства-алгоритмов-сортировки)
- [Дополнительный материал](#Дополнительный-материал)

---

В данной теме мы рассмотрим самые популярные алгоритмы сортировки массива.

Сортировкой массива называется процесс упорядочивания элементов массива по возрастанию или по убыванию.

Если тема для вас новая, и вы еще не знакомы с алгоритмами сортировки,
то наверняка при решении задачи «Отсортировать массив по возрастанию» первое что придет в голову,
это перебор, то есть: найти минимальный элемент и поменять его местами с начальным,
потом, в оставшейся части массива (кроме первого элемента),
найти снова минимальный элемент и поменять его со вторым элементом и т.д.
Такой алгоритм называется Сортировка выбором.

---

### Сортировка выбором (Selection sort)

Чтобы отсортировать массив, находим элемент с минимальным значением,
затем сравниваем его со значением первой неотсортированной позиции.
Если этот элемент меньше, то он становится новым минимумом.
Их позиции меняются.

Визуализация:

![](./selection_sort.gif)

Пример:

```java
class SelectionSort {
    void selectionSort(int[] arr) {
        // на каждом шаге слева будет появляться отсортированный элемент
        for (int i = 0; i < arr.length - 1; i++) {
            int min_idx = i;
            // поиск минимального элемента
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min_idx]) {
                    min_idx = j;
                }
            }
            // перестановка минимального элемента с первым в подмассиве
            int temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
}
```

---

### Сортировка пузырьком (Bubble sort)

Сортировка пузырьком или сортировка простыми обменами – один из простейших алгоритмов сортировки.
Он применяется для упорядочивания массивов небольших размеров.
Суть алгоритма в том, что совершается несколько проходов по массиву.
При каждом проходе попарно сравниваются два соседних элемента.
Если они находятся в верном порядке, то ничего не происходит, в противном случае они меняются местами.
В результате первого прохода максимальный элемент окажется в конце, то есть всплывет словно пузырек.
Затем все повторяется до того момента пока весь массив не будет отсортирован.

Визуализация:

![](./bubble_sort.gif)

Пример:

```java
class BubbleSort {
    void bubbleSort(int[] arr) {
        // на каждым шаге справа будет появляться отсортированный элемент
        for (int i = 0; i < arr.length - 1; i++) {
            // оптимизация алгоритма если элементы уже упорядочены
            boolean noSwaps = true;
            // перемещение самого большого элемента вправо
            for (int j = 0; j < arr.length - i - 1; j++) {
                //если два соседних элемента стоят в неправильом порядке - происходит их перестановка
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    // меняем значение если была хотя бы 1 перестановка
                    noSwaps = false;
                }
            }
            // если не было перестановок - выходим из цикла
            if (noSwaps) {
                break;
            }
        }
    }
}
```

добавив флаг **noSwaps** мы можем уменьшить количесво проходов внутреннего цикла для частично отсортированного массива.

---

### Быстрая сортировка (Quick sort)
Быстрая сортировка — в целом это один из самых быстрых алгоритмов сортировки массивов,
однако на практике он чаще всего применяется с разного рода модификациями. Является примером принципа [«разделяй и властвуй»](https://ru.wikipedia.org/wiki/Разделяй_и_властвуй_(информатика)).
Идея алгоритма заключается в том, что выбирается опорный элемент, относительно которого будет происходить сортировка.
Равные и большие элементы помещаются справа, меньшие – слева.
Затем к полученным подмассивам рекурсивно применяются два первых пункта.

Визуализация:

![](./quick_sort.gif)

Пример:

```java
class QuickSort {
    void quickSort(int[] arr) {
        sort(arr, 0, arr.length - 1);
    }

    void sort(int[] arr, int low, int high) {
        if (low < high) {
            // относительно опорного элемента размещаем элементы слева, которые меньше его 
            // и справа, которые больше. Возвращаем индекс опорного элемента
            int pi = partition(arr, low, high);
            // рекурсивно сортируем елементы слева и справа
            sort(arr, low, pi - 1);
            sort(arr, pi + 1, high);
        }
    }

    int partition(int[] arr, int low, int high) {
        // берем последний элемент в качестве опрного элемента
        // может быть выбран рандомно (Random quick sort)
        int pivot = arr[high];
        // маркер минимального индекса
        int i = low;
        for (int j = low; j < high; j++) {
            //если текущий элемент меньше либо равен опорному размещаем его слева 
            if (arr[j] <= pivot) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                // если была перестановка смещаем марвер вправо
                i++;
            }
        }
        // перестановка опорного элемента в центр
        int temp = arr[i];
        arr[i] = arr[high];
        arr[high] = temp;
        return i;
    }
}
```

---

### Случайная быстрая сортировка (Random quick sort)

Случайная быстрая сортировка – то же самое, что и быстрая сортировка, лишь с тем отличием, что опорный элемент выбирается случайно.

---

### Сортировка слиянием (Merge sort)

Сортировка слиянием – алгоритм, который сортирует такие структуры данных, где доступ к элементам осуществляется последовательно.
Эта сортировка происходит следующим образом:
массив разбивается на две примерно равные части, затем каждая из них сортируется.
После этого два отсортированных подмассива сливаются в один.
Для этого сравниваются два первых элемента в каждом из них и в зависимости от порядка сортировки ставятся в нужной последовательности.
Если же один подмассив закончился, то оставшиеся элементы второго записываются после последнего элемента первого.

Визуализация:

![](./merge_sort.gif)

Пример:

```java
class MergeSort {
    void mergeSort(int[] arr) {
        sort(arr, 0, arr.length - 1);
    }

    void sort(int[] arr, int l, int r) {
        if (l < r) {
            // делим пополам и сортируем половинки
            int m = (l + r) / 2;
            sort(arr, l, m);
            sort(arr, m + 1, r);
            // слияние подмассивов 
            merge(arr, l, m, r);
        }
    }

    void merge(int[] arr, int l, int m, int r) {
        // находим размеры подмассивов
        int n1 = m - l + 1;
        int n2 = r - m;
        // создаем временные подмасссивы
        int[] left = new int[n1];
        int[] right = new int[n2];
        // копируем данные во временные массивы
        for (int i = 0; i < n1; i++) {
            left[i] = arr[l + i];
        }
        for (int i = 0; i < n2; i++) {
            right[i] = arr[m + 1 + i];
        }

        // начальные индексы подмассивов
        int i = 0, j = 0;
        // начальные индекс массива
        int k = l;
        // слияние подмассивов
        while (i < n1 && j < n2) {
            if (left[i] <= right[j]) {
                arr[k] = left[i];
                i++;
            } else {
                arr[k] = right[j];
                j++;
            }
            k++;
        }
        // копирование оставшихся элементов если один из массивов закончился
        while (i < n1) {
            arr[k] = left[i];
            i++;
            k++;
        }
        while (j < n2) {
            arr[k] = right[j];
            j++;
            k++;
        }
    }
}
```

---

### Сортировка подсчетом (Counting sort)
Сортировка подсчетом – один из базовых алгоритмов, служит основой для многих сортировок, но сам используется только для ознакомления с темой.
Его суть в том, чтобы подсчитать сколько раз число встречается в массиве, а затем заполнить массив этими числами в соответствии с количеством.

Визуализация:

![](./counting_sort.gif)

Пример:

```java
class CountingSort {
    void countSort(int[] arr) {
        int max = arr[0];
        int min = arr[0];
        // находим максимальный и минимальный элемент
        for (int value : arr) {
            if (max < value) {
                max = value;
            }
            if (min > value) {
                min = value;
            }
        }
        // создаем массив-счетчик
        int range = max - min + 1;
        int[] count = new int[range];
        // заполняем массив-счетчик
        for (int value : arr) {
            count[value - min]++;
        }
        // заполняем исходный массив
        for (int i = 0, j = 0; i < count.length; i++) {
            for (int k = 0; k < count[i]; k++) {
                arr[j++] = i + min;
            }
        }
    }
}
```

---

### Способы оценки алгоритма

Алгоритмы сортировки оцениваются по скорости выполнения и эффективности использования памяти:

- **Время** — основной параметр, характеризующий быстродействие алгоритма.
Называется также вычислительной сложностью.
Для упорядочения важны худшее, среднее и лучшее поведение алгоритма

- **Память** — ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных.
Как правило, эти алгоритмы требуют `O(log n)` памяти.
При оценке не учитывается место, которое занимает исходный массив и независящие от входной последовательности затраты,
например, на хранение кода программы (так как всё это потребляет `O(1)`).
Алгоритмы сортировки, не потребляющие дополнительной памяти, относят к сортировкам на месте.

---

### Свойства алгоритмов сортировки

Свойства и классификации алгоритмов сортировки:

- **Устойчивость** — устойчивая сортировка не меняет взаимного расположения элементов с одинаковыми ключами

- **Естественность поведения** — эффективность метода при обработке уже упорядоченных или частично упорядоченных данных.
Алгоритм ведёт себя естественно, если учитывает эту характеристику входной последовательности и работает лучше.

- **Использование операции сравнения** - Использование операции сравнения.
Для специальных случаев (типов данных) существуют более эффективные алгоритмы

- **сфера применения**:
    - **Внутренняя сортировка** оперирует массивами, целиком помещающимися в оперативной памяти с произвольным доступом к любой ячейке.
    Данные обычно упорядочиваются на том же месте без дополнительных затрат.
    - **Внешняя сортировка** оперирует запоминающими устройствами большого объёма, но не с произвольным доступом, а последовательным (упорядочение файлов),
    то есть в данный момент «виден» только один элемент, а затраты на перемотку по сравнению с памятью неоправданно велики.
    Кроме того, доступ к данным во внешней памяти производится намного медленнее, чем операции с оперативной памятью.
    
---

### Дополнительный материал

- [Визуализация алгоритмов сортировки](https://imgur.com/gallery/voutF)
- [Все алгоритмы сортировки (WIKI, ENG)](https://en.wikipedia.org/wiki/Sorting_algorithm)

---

### [Назад к оглавлению](../README.md)