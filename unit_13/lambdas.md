# Java Lambdas

Среди новшеств, которые были привнесены в язык Java с выходом JDK 8, особняком стоят лямбда-выражения.
Лямбда представляет набор инструкций, которые можно выделить в отдельную переменную
изатем многократно вызватьв различных местах программы.

Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку `->`.
Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения,
а правая собственно представляет тело лямбда-выражения, где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе.
При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

```java
interface Operationable {
    int calculate(int x, int y);
}

public class LambdaApp {
 
    public static void main(String[] args) {
         
        Operationable operation;
        operation = (x, y) -> x + y;
         
        int result = operation.calculate(10, 20);
        System.out.println(result);
    }   
}
```

В роли функционального интерфейса выступает интерфейс Operationable,
в котором определен один метод без реализации - метод calculate.
Данный метод принимает два параметра - целых числа, и возвращает некоторое целое число.

По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.
В частности, предыдущий пример мы можем переписать следующим образом:

```java
interface Operationable {
    int calculate(int x, int y);
}

public class LambdaApp {

    public static void main(String[] args) {
        Operationable op = new Operationable() {

            public int calculate(int x, int y) {
                return x + y;
            }
        };
        int z = op.calculate(20, 10);
        System.out.println(z);
    }   
}
```

Чтобы объявить и использовать лямбда-выражение, основная программа разбивается на ряд этапов:

-   Определение ссылки на функциональный интерфейс  
    `Operationable operation;`
-   Создание лямбда-выражения  
    `operation = (x,y)->x+y;`  
    Причем параметры лямбда-выражения соответствуют параметрам единственного метода интерфейса Operationable,
    а результат соответствует возвращаемому результату метода интерфейса.
    При этом нам не надо использовать ключевое слово return для возврата результата из лямбда-выражения.
    
    Так, в методе интерфейса оба параметра представляют тип int, значит, в теле лямбда-выражения мы можем применить к ним сложение.
    Результат сложения также представляет тип int, объект которого возвращается методом интерфейса.

-   Использование лямбда-выражения в виде вызова метода интерфейса  
    `int result = operation.calculate(10, 20);`  
    Так как в лямбда-выражении определена операция сложения параметров, результатом метода будет сумма чисел 10 и 20.

При этом для одного функционального интерфейса мы можем определить множество лямбда-выражений

```java
Operationable operation1 = (int x, int y) -> x + y;
Operationable operation2 = (int x, int y) -> x - y;
Operationable operation3 = (int x, int y) -> x * y;
```

---

### Отложенное выполнение

Одним из ключевых моментов в использовании лямбд является отложенное выполнение (deferred execution).
То есть мы определяем в одном месте программы лямбда-выражение и затем можем его вызывать 
при необходимости неопределенное количество раз в различных частях программы. 
Отложенное выполнение может потребоваться, к примеру, в следующих случаях:

-   Выполнение кода в отдельном потоке
-   Выполнение одного и того же кода несколько раз
-   Выполнение кода в результате какого-то события
-   Выполнение кода только в том случае, когда он действительно необходим

---

### Передача параметров в лямбда-выражение

Параметры лямбда-выражения должны соответствовать по типу параметров метода из функционального интерфейса.
При написании самого лямбда-выражения тип параметров писать необязательно, хотя в принципе это можно сделать

```java
operation = (int x, int y) -> x + y;
```

Если метод не принимает никаких параметров, то пишутся пустые скобки

```java
() -> 30 + 20;
```

Если метод принимает только один параметр, то скобки можно опустить

```java
n -> n * n;
```

---

### Терминальные лямбда-выражения

Выше мы рассмотрели лямбда-выражения, которые возвращают определенное значение.
Но также могут быть и терминальные лямбды, которые не возвращают никакого значения

```java
interface Printable {
    void print(String s);
}

public class LambdaApp {
 
    public static void main(String[] args) {
        Printable printer = s-> System.out.println(s);
        printer.print("Hello Java!");
    } 
}
```

---

### Лямбды и локальные переменные

Лямбда-выражение может использовать переменные, которые объявлены во вне в более общей области видимости -
на уровне класса или метода, в котором лямбда-выражение определено.
Однако в зависимости от того, как и где определены переменные, могут различаться способы их использования в лямбдах.
Рассмотрим пример использования переменных уровня класса

```java
interface Operation {
    int calculate();
}

public class LambdaApp {
    static int x = 10;
    static int y = 20;
    public static void main(String[] args) {
        Operation op = () -> { 
            x = 30;
            return x + y;
        };
        System.out.println(op.calculate());
        System.out.println(x);
    }
}
```

Переменные `x` и `y` объявлены на уровне класса, и в лямбда-выражении мы их может получить и даже изменить.
Так, в данном случае после выполнения выражения изменяется значение переменной `x`.

Рассмотрим пример использования локальных переменных на уровне метода

```java
public static void main(String[] args) {
    int n=70;
    int m=30;
    Operation op = ()->{
        // n = 100; 
        return m + n;
    };
    // n = 100;
    System.out.println(op.calculate());
} 
```

Локальные переменные уровня метода мы также может использовать в лямбдах, но изменять их значение мы уже не сможем.
Если мы попробуем это сделать, то среда разработки может нам высветить ошибку и то,
что такую переменную надо пометить с помощью ключевого слова _final_, то есть сделать константой: `final int n=70;`.
Однако это необязательно.

Более того, мы не сможем изменить значение переменной, которая используется в лямбда-выражении, вне этого выражения.
То есть даже если такая переменная не объявлена как константа, по сути она является константой.

---

### Блоки кода в лямбда-выражениях

Существуют два типа лямбда-выражений: однострочное выражение и блок кода.
Примеры однострочных выражений демонстрировались выше.
Блочные выражения обрамляются фигурными скобками.
В блочных лямбда-выражениях можно использовать внутренние вложенные блоки,
циклы, конструкции if, switch, создавать переменные и т.д.
Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор return
 
```java
Operationable operation = (int x, int y)-> {
    if(y==0)
        return 0;
    else
        return x/y;
};

operation.calculate(20, 10);
```

---

### Обобщенный функциональный интерфейс

Функциональный интерфейс может быть обобщенным, однако в лямбда-выражении использование обобщений не допускается.
В этом случае нам надо типизировать объект интерфейса определенным типом, который потом будет применяться в лямбда-выражении

```java
interface Operationable<T> {
    T calculate(T x, T y);
}

public class LambdaApp {
 
    public static void main(String[] args) {
         
        Operationable<Integer> operation1 = (x, y) -> x + y;
        Operationable<String> operation2 = (x, y) -> x + y;

        System.out.println(operation1.calculate(20, 10));
        System.out.println(operation2.calculate("20", "10"));
    } 
}
```

Таким образом, при объявлении лямбд-выражения ему уже известно,
какой тип параметры будут представлять и какой тип они будут возвращать.

---

### Лямбды как параметры методов

Одним из преимуществ лямбд в java является то, что их можно передавать в качестве параметров в методы

```java
interface Expression {
    boolean isEqual(int n);
}

public class LambdaApp {
 
    public static void main(String[] args) {
        Expression func = n -> n % 2 == 0;
        int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
        System.out.println(sum(nums, func));
    } 
    
    private static int sum (int[] numbers, Expression func) {
        int result = 0;
        for(int i : numbers) {
            if (func.isEqual(i)) {
                result += i;
            }
        }
        return result;
    }
}
```

Функциональный интерфейс Expression определяет метод isEqual(), который возвращает true,
если в отношении числа n действует какое-нибудь равенство.

В основном классе программы определяется метод sum(), который вычисляет сумму всех элементов массива, соответствующих некоторому условию.
А само условие передается через параметр `Expression func`.
Причем на момент написания метода sum мы можем абсолютно не знать, какое именно условие будет использоваться.
Само же условие определяется в виде лямбда-выражения `Expression func = n -> n % 2 == 0;`

То есть в данном случае все числа должны быть четными или остаток от их деления на 2 должен быть равен 0.
Затем это лямбда-выражение передается в вызов метода sum.

При этом можно не определять переменную интерфейса, а сразу передать в метод лямбда-выражение

```java
int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int x = sum(nums, (n)-> n > 5);
System.out.println(x);
```

---

### Лямбды как результат методов

Также метод в Java может возвращать лямбда-выражение

```java
interface Operation {
    int execute(int x, int y);
}
 
public class LambdaApp {
  
    public static void main(String[] args) {
          
        Operation func = action(1);
        int a = func.execute(6, 5);
        System.out.println(a);
         
        int b = action(2).execute(8, 2);
        System.out.println(b);
    } 
     
    private static Operation action(int number){
        switch(number){
            case 1: return (x, y) -> x + y; 
            case 2: return (x, y) -> x - y; 
            case 3: return (x, y) -> x * y; 
            default: return (x,y) -> 0;
        }
    }
}
```

В данном случае определен функциональный интерфейс Operation,
в котором метод execute принимает два значения типа int и возвращает значение типа int.

Метод action принимает в качестве параметра число и в зависимости от его значения возвращает лямбда-выражение.
Оно может представлять либо сложение, либо вычитание, либо умножение, либо просто возвращает 0.
Стоит учитывать, что формально возвращаемым типом метода action является интерфейс Operation,
а возвращаемое лямбда-выражение соответствует этому интерфейсу.

В методе main мы можем вызвать этот метод action. 
Например, сначала получить его результат - лямбда-выражение, которое присваивается переменной Operation,
а затем через метод execute выполнить это лямбда-выражение.

Либо можно сразу получить и тут же выполнить лямбда-выражение

---

### [Назад к оглавлению](./README.md)