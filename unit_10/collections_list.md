# Интерфейс List и класс ArrayList

Для создания простых списков применяется интерфейс `List`, который расширяет функцональность интерфейса `Collection`.
Некоторые наиболее часто используемые методы интерфейса `List`:

-   `void add(int index, E obj)` добавляет в список по индексу **index** объект **obj**
-   `boolean addAll(int index, Collection<? extends E> col)` добавляет в список по индексу index все элементы коллекции **col**.
    Если в результате добавления список был изменен, то возвращается **true**, иначе возвращается **false**
-   `E get(int index)` возвращает объект из списка по индексу **index**
-   `int indexOf(Object obj)` возвращает индекс первого вхождения объекта **obj** в список.
    Если объект не найден, то возвращается **-1**
-   `int lastIndexOf(Object obj)` возвращает индекс последнего вхождения объекта **obj** в список.
    Если объект не найден, то возвращается **-1**
-   `ListIterator<E> listIterator()` возвращает объект **ListIterator** для обхода элементов списка
-   `static <E> List<E> of(E... items)` создает из набора элементов объект **List**
-   `E remove(int index)` удаляет объект из списка по индексу **index**, возвращая при этом удаленный объект
-   `E set(int index, E obj)` присваивает значение объекта **obj** элементу, который находится по индексу **index**
-   `void sort(Comparator<? super E> comp)` сортирует список с помощью компаратора **comp**
-   `List<E> subList(int start, int end)` получает набор элементов, которые находятся в списке между индексами **start** и **end**

По умолчанию в Java есть встроенная реализация этого интерфейса - класс `ArrayList`.
Класс `ArrayList` представляет обобщенную коллекцию, которая наследует свою функциональность
от класса `AbstractList` и применяет интерфейс `List`.
Другими словами, ArrayList представляет простой список, аналогичный массиву, за тем исключением,
что количество элементов в нем не фиксировано.

`ArrayList` имеет следующие конструкторы:

-   `ArrayList()` создает пустой список
-   `ArrayList(Collection <? extends E> col)` создает список, в который добавляются все элементы коллекции `col`
-   `ArrayList(int capacity)` создает список, который имеет начальную емкость `capacity`

Емкость в `ArrayList` представляет размер массива, который будет использоваться для хранения объектов.
При добавлении элементов фактически происходит перераспределение памяти -
создание нового массива и копирование в него элементов из старого массива.
Изначальное задание емкости `ArrayList` позволяет снизить подобные перераспределения памяти, тем самым повышая производительность.

Пример использования класса `ArrayList` и некоторых его методов

```java
import java.util.ArrayList;
 
public class Program{
      
    public static void main(String[] args) {
          
        ArrayList<String> people = new ArrayList<>();
        // добавление элемента
        people.add("Tom");
        people.add("Alice");
        people.add("Kate");
        

        // добавление элемента по индексу 1
        people.add(1, "Bob");
        people.add(2, "Sam");
        
        // получение 2-ого элемента
        System.out.println(people.get(1));
        // установка нового значения 2-му элементу
        people.set(1, "Robert"); 
          
        System.out.printf("ArrayList has %d elements \n", people.size());
        for(String person : people){
          
            System.out.println(person);
        }

        // проверка наличия элемента
        if(people.contains("Tom")){
          
            System.out.println("ArrayList contains Tom");
        }
          
        // удаление конкретного элемента
        people.remove("Robert");
        // удаление по индексу
        people.remove(0);
          
        Object[] peopleArray = people.toArray();
        for(Object person : peopleArray){
            System.out.println(person);
        }
    }
}
```

Здесь объект `ArrayList` типизируется классом **String**, поэтому список будет хранить только строки.
Поскольку класс ArrayList применяет интерфейс `Collection<E>`,
то мы можем использовать методы данного интерфейса для управления объектами в списке.

Для добавления вызывается метод `add()`.
С его помощью мы можем добавлять объект в конец списка `people.add("Tom")`.
Также можно добавить объект на определенное место в списке по индексу `people.add(1, "Bob")` (добавление элемента на второе место)

Метод `size()` позволяет узнать количество объектов в коллекции.
Проверку на наличие элемента в коллекции производится с помощью метода `contains()`.
А удаление с помощью метода `remove()`.
Так же, как и с добавлением, можно удалить либо конкретный элемент `people.remove("Tom");`,
либо элемент по индексу `people.remove(0);` (удаление первого элемента)

Получить определенный элемент по индексу мы можем с помощью метода _get()_ `String person = people.get(1);`,
а установить элемент по индексу с помощью метода _set()_ people.set(1, "Robert");

С помощью метода `toArray()` мы можем преобразовать список в массив объектов.
Поскольку класс `ArrayList` реализует интерфейс `Iterable`, то мы можем пробежаться по списку в цикле for-each `for(String person : people)`.

Хотя мы можем свободно добавлять в объект `ArrayList` дополнительные объекты,
в отличие от массива, однако в реальности `ArrayList` использует для хранения объектов опять же массив.
По умолчанию данный массив предназначен для **10** объектов.
Если в процессе программы добавляется гораздо больше, то создается новый массив, который может вместить в себя все количество.
Подобные перераспределения памяти уменьшают производительность.
Поэтому если мы точно знаем, что у нас список не будет содержать больше определенного количества элементов, например, **25**, 
то мы можем сразу же явным образом установить это количество, либо в конструкторе -
`ArrayList<String> people = new ArrayList<String>(25);`, либо с помощью метода _ensureCapacity_ - `people.ensureCapacity(25);`

---

### [Назад к оглавлению](./README.md)
