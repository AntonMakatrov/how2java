# Аннотации

**Аннотация** - средство, что позволяет встроить информацию поддержки в исходные файлы,
то есть аннотации можно использовать для отслеживания ошибок, устранения предупреждений, генерации кода, XML файлов.
Появились с версии Java 1.5.

Аннотация присваивает дополнительные метаданные исходному коду, с которым она связана.
Добавляя аннотацию к методу, интерфейсу, классу или полю, можно:

-   Сообщить компилятору о предупреждениях и ошибках
-   Манипулировать исходным кодом во время компиляции
-   Изменить или изучить поведение во время выполнения

---

### Встроенные аннотации

В Java определено много полезных встроенных аннотаций, большинство из их являются специализированными.
Аннотации, что имеют общее назначение:

-   `@Retention` эта аннотация предназначена для применения только в качестве аннотации к другим аннотациям.
    Определяет политику удержания.
-   `@Documented` это маркер-интерфейс, который сообщает инструменту,
    что аннотация должна быть документирована.
-   `@Target` эта аннотация задает тип объявления, к которым может быть применима аннотация.
    Принимает один аргумент, который должен быть константой из перечисления **ElementType**.
    Например, чтобы указать, что аннотация применима только к полям и локальным переменным:  
    **@Target({ ElementType.FIELD, ElementType.LOCAL_VARIABLE })**
-   `@Inherited` это аннотация-маркер, которая может применяться в другом объявление аннотации,
    она касается только тех аннотаций, что будут использованы в объявлениях классов.
    Эта аннотация позволяет аннотации супер класса быть унаследованной в подклассе.
-   `@Override` аннотация-маркер, которая может применяться только к методам.
    Метод, аннотированный как **@Override**, должен переопределять метод супер класса.
-   `@Deprecated` указывает, что объявление устарело и должно быть заменено более новой формой.
-   `@SafeVarargs` аннотация-маркер, применяется к методам и конструкторам.
    Она указывает, что никакие небезопасные действия, связанные с параметром переменного количества аргументов, недопустимы.
    Применяется только к методам и конструкторам с переменным количеством аргументов, которые объявлены как **static** или **final**.
-   `@SuppressWarnings` эта аннотация указывает, что одно или более предупреждений,
    которые могут быть выданы компилятором следует подавить.
-   `@Repeatable` Иногда может быть полезно указывать одну и ту же аннотацию более одного раза для данного элемента Java.
-   `@FunctionalInterface` позволяет нам писать код более функциональным способом (Java 8)

---

### Удержание аннотации. @Retention

Некоторые аннотации предназначены для использования в качестве подсказок для компилятора,
в то время как другие используются во время выполнения.

Существует 3 политики удержания аннотации.
Политика удержания определяет, в какой точке аннотация сбрасывается.
Такие политики инкапсулированы в перечисление `java.lang.annotation.RetentionPolicy`: 

-   `SOURCE` аннотации содержаться только в исходном файле и отбрасываются при компиляции.
-   `CLASS` аннотации сохраняются в файле, однако они недоступны JVM во время выполнения.
-   `RUNTIME` аннотации сохраняются в файле во время компиляции и остаются доступными JVM во время выполнения.

Мы используем аннотацию `@Retention`, чтобы указать, где в жизненном цикле нашей программы применяется наша аннотация.

по умолчанию политика удержания - **RetentionPolicy.SOURCE**

---

### @Repeatable

Иногда может быть полезно указывать одну и ту же аннотацию более одного раза для данного элемента Java.
До Java 7 нужно было группировать аннотации в одну аннотацию контейнера:

```java
public class Alarm {
    @Schedules({
        @Schedule(time = "15:05"),
        @Schedule(time = "23:00")
    })
    void scheduledAlarm() {
    }
}
```

Тем не менее, Java 7 принесла более чистый подход.
С аннотацией `@Repeatable` мы можем сделать аннотацию повторяемой:

```java
@Repeatable(Schedules.class)
public @interface Schedule {
    String time() default "09:00";
}

public @interface Schedules {
    Schedule[] value();
}

public class Alarm {
    @Schedule
    @Schedule(time = "15:05")
    @Schedule(time = "23:00")
    void scheduledAlarm() {

    }
}


```

---

### Создание собственных аннотаций

Аннотации создаются с использование механизма, основанного на интерфейсе.
Пример объявления аннотации:

```java
@interface MyAnnotation { 
String str(); 
int val(); 
} 
```

Символ `@` - указывает компилятору, что объявлена аннотация.
Методы, объявленные в аннотации ведут себя скорее как поля.

```java
@MyAnnotation(str = "hello", val = 15) 
public static void myMethod() {

} 
```

Для аннотирования метода надо за именем аннотации, записать в скобках список инициализируемых членов.

---

### Получение аннотации

**Рефлексия** - это средство позволяющее получить информацию о классе во время выполнения программы.
Первый шаг в использование рефлексии - это получение объекта **Class** `Class<?>  c = ob.getClass(); `

Далее используя объект типа **Class** вы можете получить информацию о различных элементах, объявленных в классе включая аннотацию.

```java
Class<?> c = ob.getClass(); 
Method m = c.getMethod("myMethod"); 
MyAnnotation anno = m.getAnnotation(MyAnnotation.class); 
```

---

### [Назад к оглавлению](./README.md)