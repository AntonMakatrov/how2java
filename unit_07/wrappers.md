# Классы-оболочки / обертки (wrappers)

- [Определение](#Определение-классов-оболочек)
- [Назначение](#Назначение-классов-оболочек-в-Java)
- [Автоупаковка](#Автоупаковка-в-Java)
- [Распаковка](#Распаковка-в-Java)
- [Класс BigInteger](#Класс-java.math.BigInteger)
- [Класс BigDecimal](#Класс-java.math.BigDecimal)

---

### Определение классов-оболочек

Обертка — это специальный класс, который хранит внутри себя значение примитива. 

В Java у каждого примитивного типа есть свой брат-близнец — класс-обертка (`Wrapper`)

| примитивный тип   | класс-обертка
| ---               | ---
| byte              | [Byte](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Byte.html)
| short             | [Short](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Short.html)
| int               | [Integer](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Integer.html)
| long              | [Long](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Long.html)
| float             | [Float](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Float.html)
| double            | [Double](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Double.html)
| char              | [Character](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Character.html)
| boolean           | [Boolean](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Boolean.html)

Числовые классы имеют общего предка — абстрактный класс [Number](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Number.html), 
в котором описаны шесть методов, возвращающих числовое значение,
содержащееся в классе, приведенное к соответствующему примитивному типу:
- `byteValue()`
- `doubleValue()`
- `floatValue()`
- `intValue()`
- `longValue()`
- `shortValue()`

Эти методы переопределены в каждом из шести числовых классов-оболочек

---

### Назначение классов-оболочек в Java

Разработчиками языка Java было принято решение отделить примитивные типы и классы-оболочки, указав при этом следующее:

-   Используйте классы-обертки, когда работаете с коллекциями
-   Используйте примитивные типы для того, чтобы ваши программы были максимально просты (занимают меньше места)

Кроме того, есть ситуации, когда нельзя использовать объекты,
или наоборот, когда можно использовать только объекты.

Одним из важных моментов является то, что примитивные типы не могут быть `null`, а классы-оболочки — могут.

Также классы-оболочки могут быть использованы для достижения полиморфизма.

```java
import java.util.ArrayList;
import java.util.List;
 
public class WrapperClasses {
 
    private static void doSomething(Object obj) {
         
    }
      
    public static void main(String args[]) {
        int i = 10;
        char c = 'a';
        
        //примитивы просты в использовании
        int j = i + 3; 
         
        //полиморфизм достигается с помощью классов-оболочек, мы не можем использовать примитивы здесь
        doSomething(new Character(c));
         
        List<Integer> list = new ArrayList<>();
        //классы-оболочки могут быть использованы в коллекциях
        Integer in = new Integer(i);
        list.add(in);
         
        //Автоупаковка заботится о преобразовании примитива в соответственный класс-оболочку
        list.add(j);
         
        //классы-оболочки могут быть null
        in = null;
    }
}
```

---

### Автоупаковка в Java

Преобразование примитивного типа данных в объект соответствующего класса-оболочки называется автоупаковкой.
Например, преобразование `int` в `Integer` или преобразования `long` в `Long`.

Компилятор Java применяет автоупаковку при таких значениях примитива:
-   Примитив пришел в параметр метода, который ожидает объект соответствующего класса-оболочки.
    Например, в метод с параметром `Integer` можно передавать `int` — компилятор Java будет преобразовывать `int` в `Integer`
-   Присваивание переменной значение соответствующего класса-оболочки.
    Например, переменная типа `Long` может принимать `long`.

---

### Распаковка в Java

Присваивание объекта класса-оболочки переменной примитивного типа.
Например, переменная типа `long` может принимать `Long`.

Компилятор Java применяет распаковку в таком случае:
-   Объект класса-оболочки пришел в параметр метода, который ожидает значение соответствующего примитивного типа
-   Присваивание переменной примитивного типа соответствующего объекта класса-оболочки

```java
import java.util.ArrayList;
import java.util.List;
 
public class AutoboxingUnboxing {
 
    public static void main(String[] args) {
        int i = 5;
        long j = 105L;
         
        //пришел int, значит будет преобразование в объект Integer
        doSomething(i);
         
        List<Long> list = new ArrayList<>();
        //автоупаковка примитивного типа в соответствующий класс-оболочку
        list.add(j);
    }
 
    private static void doSomething(Integer in){
        //распаковка, во время выполнения Integer.intValue()
        int j = in;
         
        //распаковка: передается Integer, где ожидался int
        doPrimitive(in);
    }
 
    private static void doPrimitive(int i) {
         
    }
}
```

---

### Класс java.math.BigInteger

Все примитивные целые типы имеют ограниченный диапазон значений.
В целочисленной арифметике Java нет переполнения, целые числа приводятся по модулю, равному диапазону значений.

Для того чтобы было можно производить целочисленные вычисления с любой разрядностью,
в состав Java API введен класс `BigInteger`.
Этот класс расширяет класс Number, следовательно, в нем переопределены методы:

- `doubleValue()`
- `floatValue()`
- `intValue()`
- `longValue()`

Методы `byteValue()` и `shortValue()` не переопределены, а прямо наследуются от класса Number.

Действия с объектами класса `BigInteger` не приводят ни к переполнению, ни к приведению по модулю.
Если результат операции велик, то число разрядов просто увеличивается.
Числа хранятся в двоичной форме с дополнительным кодом.

Перед выполнением операции числа выравниваются по длине распространением знакового разряда.

Две константы — `ZERO` и `ONE` — моделируют ноль и единицу в операциях с объектами класса BigInteger.

---

### Класс java.math.BigDecimal

Каждый объект этого класса хранит два целочисленных значения:
мантиссу вещественного числа в виде объекта класса BigInteger,
и неотрицательный десятичный порядок числа типа int.

Например, для числа `76.34862` будет храниться мантисса `7 634 862` в объекте класса `BigInteger`, 
и порядок `5` как целое число типа `int`.
Таким образом, мантисса может содержать любое количество цифр,
а порядок ограничен значением константы `Integer.MAX_VALUE`

Этот класс так же расширяет класс `Number` и в нем переопределены методы:

- `doubleValue()`
- `floatValue()`
- `intValue()`
- `longValue()`

---

### [Назад к оглавлению](./README.md)